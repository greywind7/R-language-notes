# check arguments of read.table
args(read.table)
source('~/.active-rstudio-document')
x <- c('a','b','c','d')
x[1]
x[1:3]
# Logical subsetting
x[x > 'a']
# Logical vector
u <- x > a
u
# Logical vector
u <- x > 'a'
u
x[u]
# ********************Subsetting Lists********************
lst <- list(foo = 1:4, bar = 0.6)
# Single brackets will return a list
lst[1]
# Double bracket will return an elemment
lst[[1]]
# $ will return the element associated with that name
lst$foo
# multiple subsetting, pass a list
lst[c(1,3)]
source('~/Documents/RProgs/Sunsetting.R')
# multiple subsetting, pass a list
lst[c(1,3)]
# Nested subsetting
lst[[c(1,2)]]
lst[[1]][[2]]
# ********************Subsetting matrix********************
matri <- matrix(1:100, nrow = 10, ncol = 10, byrow = TRUE)
matri
# Use both indices to extract an eleement
matri[1][2]
# Use both indices to extract an eleement
matri[1,2]
# Miss indices to extract whole column or row
matri[2,]
matri[,2]
# use drop = FALSE to retain dimensionality
matri[2,3 drop = F]
# use drop = FALSE to retain dimensionality
matri[2,3, drop = F]
# Partial matching:
# -> $ works like autocomplete in shell
# -> You can simply give first letter and it will match
# -> In [[]] you have to set exact = F
lst$f
lst[['d', exact = F]]
lst[['b', exact = F]]
lst[['ba', exact = F]]
lst[['f', exact = F]]
# ********************Removing missing vsl.********************
mvl <- c(1,2,NA,NA,5,6,NA)
bad <- is.na(mvl)
mvl[!bad]
good <- complete.cases(mvl)
mvl[good]
# ************************Functions************************
# Syntax
add2 <- function(x,y){
x + y
}
add2(2,3)
above(1:10,5)
above <- function(x,n){
use <- x > n
x[use]
}
above(1:10,5)
source('~/Documents/RProgs/Functions,Dates.R')
?unclass
# ************************Date,Time************************
# Times are represented by POSIXct or POSIXlt classes
# ct stores a very big integer (as a vector)
# lt stores many underlying informations (as a list)
tm <- Sys.time()
tm
t2 <- as.POSIXlt()
t2
t2 <- as.POSIXlt()
t2 <- as.POSIXlt(tm)
t2
names(unclass(t2))
# ************************Loop Func.************************
# lapply() takes a list as an argument and does stuff to it
X <- list(a = 1:5, b = rnorm(10))
# ************************Loop Func.************************
# lapply() takes a list as an argument and does stuff to it
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
?runif
# ************************Extras************************
# runif, it generates random variables between a range
# Anonymous functions, short snippet functions
lapply(1:5, function(elt) elt^2)
?which
# apply() is basically used on a matrix
# It collapses a diimension of a matrix
y <- matrix(rnorm(200),20,10)
apply(y,2,mean)
# mapply() works on multiple arguments
mapply(rep, 1:4, 4;1)
# mapply() works on multiple arguments
mapply(rep, 1:4, 4:1)
?tapply(vector, index, function)
?tapply
?gl
# any() returns true if any value is true
# all() returns true if all is true
# which() incides which are true
# gl() generates factor levels
# split() breaks a vector into groups based on factors
z <- c(rnorm(10),runif(10),rnorm(10,1))
f <- gl(3,10)
split(x,f)
split(z,f)
# It breaks, tapply() does a function to it
# further uses
library(datasets)
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]))
head(airquality)
sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]))
sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]), na.rm = T)
sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]na.rm = T))
sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")],na.rm = T))
# all() returns true if all is true
# which() incides which are true
# gl() generates factor levels
# datasets library has datasets
# rowSums,rowMeans,colSums,colMeans
# na.rm in functions
# ************************Date,Time************************
# Times are represented by POSIXct or POSIXlt classes
# ct stores a very big integer (as a vector)
# lt stores many underlying informations (as a list)
tm <- Sys.time()
# multiple factors
f1 <- gl(2,5)
f2 <- gl(5,2)
split(z,list(f1,f2))
